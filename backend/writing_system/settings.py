"""
Django settings for writing_system project.

Generated by 'django-admin startproject' using Django 4.2.17.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""
from pathlib import Path
from dotenv import load_dotenv # type: ignore
import os
from datetime import timedelta
try:
    from celery.schedules import crontab # type: ignore
except ImportError:
    # Celery not installed, define a dummy crontab function
    def crontab(*args, **kwargs):
        return None
from urllib.parse import quote_plus
# import sentry_sdk
# from sentry_sdk.integrations.django import DjangoIntegration

try:
    from cryptography.fernet import Fernet # type: ignore
except ImportError:
    # Cryptography not installed, define a dummy Fernet class
    class Fernet:
        @staticmethod
        def generate_key():
            return b'dummy-key'

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
load_dotenv(os.path.join(BASE_DIR, ".env"))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv('DEBUG', 'True') == 'True'

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')
# Handle empty strings as if not set
if SECRET_KEY == '':
    SECRET_KEY = None

if not SECRET_KEY:
    if DEBUG:
        # Generate a default key for development/testing
        # WARNING: This should NEVER be used in production
        import secrets
        SECRET_KEY = secrets.token_urlsafe(50)
        import warnings
        warnings.warn(
            "SECRET_KEY not set. Using auto-generated key for development. "
            "This should be set explicitly in production!",
            RuntimeWarning
        )
    else:
        from django.core.exceptions import ImproperlyConfigured
        raise ImproperlyConfigured("The SECRET_KEY setting must not be empty.")

ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "localhost,127.0.0.1").split(",")

# Frontend URL for email links (activation, password reset)
FRONTEND_URL = os.getenv("FRONTEND_URL", "http://localhost:5173")


# Application definition

INSTALLED_APPS = [
    # Django Default Apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'drf_spectacular',
    'drf_spectacular_sidecar',
    'django_ratelimit',
    'django_filters',
    'django_celery_beat',
    'django_otp',
    'django_otp.plugins.otp_totp',
    'drf_yasg',
    # "notifications_system.apps.NotificationsSystemConfig",
    # 'django_celery_results',
    

    # Third-party Apps
    'rest_framework',
    'corsheaders',
    # 'drf-queryfields',
    # 'django-rq',

    'celery',
    'channels',
    'django_countries',
    "rest_framework_simplejwt",
    "rest_framework_simplejwt.token_blacklist",
    "import_export", 


    # Core Project Apps
    'core',
    'websites',
    'audit_logging',
    'users',
    'authentication',
    'communications',


     # Financial Apps
    'wallet',
    'client_wallet',
    'writer_wallet',
    'discounts',
    'referrals',
    'fines',
    'refunds',
    
    # Order Management
    'orders',
    'order_payments_management',
    'order_files',
    'order_configs',
    'pricing_configs',
    'pricing',
    'special_orders',
    'class_management',
    # 'orders.apps.OrdersConfig',  # Custom AppConfig for Orders


   

    # Notifications and Support
    'notifications_system',
    'tickets',
    'mass_emails',
    'announcements',  # Announcements Center
    'analytics',
    'holiday_management',  # Holiday and special day management

    # Users Management Apps
    'superadmin_management',
    'admin_management',
    'client_management',
    'writer_management',
    'writer_payments_management',
    'editor_management',
    'support_management',
    'loyalty_management',
    'activity',
    'reviews_system',

    # Content Management Apps
    'blog_pages_management',
    'service_pages_management',
    'seo_pages',

    # Media & Content Assets
    'media_management',

     # Shared Utilities App
    #  "common",
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',  # CORS middleware (must be before CommonMiddleware)
    'core.middleware.graceful_degradation.GracefulDegradationMiddleware',  # Graceful degradation - early in chain
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'authentication.middleware.session_timeout.SessionTimeoutMiddleware',  # Session idle timeout
    'audit_logging.middleware.AuditUserMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'superadmin_management.middleware.BlacklistMiddleware',
    'core.middleware.compression.EnhancedCompressionMiddleware',  # Enhanced compression with better control
    "activity.middleware.ActivityAuditMiddleware",
    "notifications_system.middleware.sse_middleware.SSEAuthMiddleware",
    "core.middleware.performance_monitoring.PerformanceMonitoringMiddleware",  # Performance monitoring
]

ROOT_URLCONF = 'writing_system.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'writing_system.wsgi.application'

AUTH_USER_MODEL = 'users.User'

# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('POSTGRES_DB_NAME') or 'writingsondo',  #Database Name with fallback
        'USER': os.getenv('POSTGRES_USER_NAME') or 'awinorick',  #Database username with fallback
        'PASSWORD': os.getenv('POSTGRES_PASSWORD') or 'Nyakach2030',  #Database password with fallback (matches docker-compose default)
        "HOST": os.getenv("DB_HOST", "db"),  # Hostname
        "PORT": os.getenv("DB_PORT", 5432),  # Port
    }
}


print("Database:", os.getenv("POSTGRES_DB_NAME"))
print("User:", os.getenv("POSTGRES_USER_NAME"))
print("DATABASE PASSWORD:", os.getenv('POSTGRES_PASSWORD'))
print("DATABASE HOST:", os.getenv('DB_HOST', 'db'))
print("DATABASE PORT:", os.getenv('DB_PORT', 5432))

# Password hashing
# https://docs.djangoproject.com/en/4.2/topics/auth/passwords/#password-hashing
# Argon2 is the winner of the Password Hashing Competition (2015) and is the most secure option
PASSWORD_HASHERS = [
    # Note: Argon2 requires argon2-cffi package. If not installed, Django will fall back to PBKDF2
    # To install: docker-compose exec -u root web pip install argon2-cffi==25.1.0
    # Or rebuild container: docker-compose build web && docker-compose up -d
    'django.contrib.auth.hashers.Argon2PasswordHasher',  # Best security - memory-hard algorithm
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',  # Fallback for existing passwords and if argon2 not available
    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
    'django.contrib.auth.hashers.BCryptPasswordHasher',
]

# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')


# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# CORS configuration for frontend development
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",
    "http://localhost:5174",
    "http://127.0.0.1:5173",
    "http://127.0.0.1:5174",
    "http://localhost:5175",
    "http://127.0.0.1:5175",
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://localhost:8000",  # Backend (for admin)
    "http://127.0.0.1:8000",  # Backend (for admin)
]
CORS_ALLOW_CREDENTIALS = True
CORS_ALLOW_ALL_ORIGINS = DEBUG  # Allow all origins in debug mode

# CSRF trusted origins for local dev
CSRF_TRUSTED_ORIGINS = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:5175",
    "http://127.0.0.1:5175",
]



PASSKEY_CHALLENGE_TTL = 300  # 5 minutes
PASSKEY_REDIS_PREFIX = "passkey"

SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"

# Session idle timeout settings (in seconds)
# Session idle timeout - only applies to session-based auth, not JWT
# JWT tokens have their own expiration (ACCESS_TOKEN_LIFETIME = 1 day)
SESSION_IDLE_TIMEOUT = int(os.getenv("SESSION_IDLE_TIMEOUT", 8 * 60 * 60))  # Default: 8 hours (increased from 30 min)
SESSION_WARNING_TIME = int(os.getenv("SESSION_WARNING_TIME", 30 * 60))   # Default: 30 minutes before timeout (increased from 5 min)



SPECTACULAR_SETTINGS = {
    'TITLE': 'Writing System Backend API',
    'DESCRIPTION': """
    Complete API documentation for the Writing System Backend.
    
    ## Features
    - User authentication and management
    - Order placement and management
    - Payment processing (unified workflow)
    - Discount management with stacking
    - Special orders
    - Class bundle management
    - File management
    - Communications and messaging
    - Support tickets
    - Writer and client management
    
    ## Authentication
    Use JWT tokens for authenticated requests. Get tokens via `/api/v1/auth/login/`
    
    ## Impersonation
    Admins and superadmins can impersonate users to help resolve issues.
    Use `/api/v1/users/{id}/impersonate/` endpoint.
    
    ## Rate Limiting
    API is rate-limited. Check response headers for rate limit information.
    """,
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    'SCHEMA_PATH_PREFIX': r'/api/',
    'COMPONENT_SPLIT_REQUEST': True,
    'COMPONENT_NO_READ_ONLY_REQUIRED': True,
    'SERVE_PERMISSIONS': ['rest_framework.permissions.AllowAny'],
    'SERVE_AUTHENTICATION': None,
    'SWAGGER_UI_SETTINGS': {
        'deepLinking': True,
        'displayOperationId': False,
        'defaultModelsExpandDepth': 1,
        'defaultModelExpandDepth': 1,
        'displayRequestDuration': True,
        'docExpansion': 'list',
        'filter': True,
        'showExtensions': True,
        'showCommonExtensions': True,
    },
    'REDOC_UI_SETTINGS': {
        'hideDownloadButton': False,
        'expandResponses': '200,201',
        'pathInMiddlePanel': True,
    },
    'APPEND_COMPONENTS': {
        'securitySchemes': {
            'JWT': {
                'type': 'http',
                'scheme': 'bearer',
                'bearerFormat': 'JWT',
            }
        }
    },
    'SECURITY': [{'JWT': []}],
}

# Channels Settings
# ASGI_APPLICATION = "writing_system.asgi.application"
ALLOWED_HOSTS = os.getenv("ALLOWED_HOSTS", "localhost,127.0.0.1").split(",")


REDIS_HOST = os.getenv("REDIS_HOST", "redis")  # Default to localhost if not set
REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))  # Default Redis port
REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", "")  # Default Redis password

# REDIS_SSL = os.getenv("REDIS_SSL", "false").lower() in ("1", "true", "yes")


# # Build the Redis cache location URL
# if REDIS_PASSWORD:
#     _pwd = os.getenv("REDIS_PASSWORD")
#     CELERY_BROKER_URL = f"redis://:{quote_plus(_pwd)}@{REDIS_HOST}:{REDIS_PORT}/0"
#     CELERY_RESULT_BACKEND = CELERY_BROKER_URL
#     redis_password = quote_plus(REDIS_PASSWORD)
#     redis_cache_url = f"redis://:{redis_password}@{REDIS_HOST}:{REDIS_PORT}/1"
# else:
#     redis_cache_url = f"redis://{REDIS_HOST}:{REDIS_PORT}/1"
#     CELERY_BROKER_URL = f"redis://{REDIS_HOST}:{REDIS_PORT}/0"
#     CELERY_RESULT_BACKEND = CELERY_BROKER_URL



def _redis_url(db: int) -> str:
    # Only include password if it's set and not empty
    if REDIS_PASSWORD and REDIS_PASSWORD.strip():
        return (
            f"redis://:{quote_plus(REDIS_PASSWORD)}@"
            f"{REDIS_HOST}:{REDIS_PORT}/{db}"
        )
    return f"redis://{REDIS_HOST}:{REDIS_PORT}/{db}"


# # WebSocket Backend
# CHANNEL_LAYERS = {
#     "default": {
#         "BACKEND": "channels_redis.core.RedisChannelLayer",
#         "CONFIG": {
#             "hosts": [
#                 {
#                     "address": (REDIS_HOST, REDIS_PORT),
#                     **({"password": REDIS_PASSWORD} if REDIS_PASSWORD else {}),
#                     #  **({"ssl": True} if REDIS_SSL else {}),
#                     # Only enable SSL if you *know* Redis uses TLS
#                 }
#             ],
#             "capacity": 10000,  # Optional: number of messages allowed in a channel
#             "expiry": 60,       # Optional: seconds to keep messages before expiring
#         }
#     },
# }



REDIS_URL = _redis_url(0)
CELERY_BROKER_URL = REDIS_URL
CELERY_RESULT_BACKEND = REDIS_URL
# CACHES["default"]["LOCATION"] = _redis_url(1)

# Redis (if used for caching)
CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": _redis_url(1),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
            # Only include PASSWORD in OPTIONS if you actually have one:
            **({"PASSWORD": REDIS_PASSWORD} if REDIS_PASSWORD else {}),
            "SOCKET_CONNECT_TIMEOUT": 5,  # Fail fast if Redis is unreachable
            "SOCKET_TIMEOUT": 5,
            # Optional SSL setup if using TLS
            # "CONNECTION_POOL_KWARGS": {"ssl": bool(os.getenv("REDIS_SSL", False))}
        }
    }
}

# Celery settings
# CELERY_BROKER_URL = os.getenv(
#     "CELERY_BROKER_URL",
#     f"redis://:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/0",
# )
# CELERY_RESULT_BACKEND = CELERY_BROKER_URL
# # Celery Configuration Options
# CELERY_TIMEZONE = "Australia/Tasmania"
# CELERY_TASK_TRACK_STARTED = True
# CELERY_TASK_TIME_LIMIT = 30 * 60
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True
RQ_QUEUES = {
    'default': {
        'USE_REDIS_CACHE': 'default',  # Use Redis as the backend
        'URL': _redis_url(0),  # Redis URL
        'DB': 0,
        'DEFAULT_TIMEOUT': 360,
    }
}

# Email Settings
EMAIL_BACKEND = os.getenv(
    "EMAIL_BACKEND",
    "django.core.mail.backends.smtp.EmailBackend"
)
EMAIL_HOST = os.getenv(
    "EMAIL_HOST", "smtp.gmail.com"
)
EMAIL_PORT = int(os.getenv("EMAIL_PORT", 587))
EMAIL_USE_TLS = os.getenv("EMAIL_USE_TLS", "True") == "True"
EMAIL_HOST_USER = os.getenv("EMAIL_HOST_USER")
EMAIL_HOST_PASSWORD = os.getenv("EMAIL_HOST_PASSWORD")
DEFAULT_FROM_EMAIL = os.getenv(
    "DEFAULT_FROM_EMAIL", EMAIL_HOST_USER
)

# Geolocation API Key
GEOLOCATION_API_KEY = os.getenv("GEOLOCATION_API_KEY")



#  Media & File Storage
# Storage backend: 'do_spaces' (DigitalOcean Spaces), 's3' (AWS S3), or 'local'
STORAGE_BACKEND = os.getenv('STORAGE_BACKEND', 'local')

if STORAGE_BACKEND in ['do_spaces', 's3']:
    # Cloud storage configuration (DigitalOcean Spaces or AWS S3)
    AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
    AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
    AWS_STORAGE_BUCKET_NAME = os.getenv('AWS_STORAGE_BUCKET_NAME')
    
    if STORAGE_BACKEND == 'do_spaces':
        # DigitalOcean Spaces (S3-compatible)
        DO_SPACES_REGION = os.getenv('DO_SPACES_REGION', 'nyc3')
        AWS_S3_ENDPOINT_URL = f'https://{DO_SPACES_REGION}.digitaloceanspaces.com'
        AWS_S3_REGION_NAME = DO_SPACES_REGION
        AWS_S3_CUSTOM_DOMAIN = os.getenv('DO_SPACES_CDN_ENDPOINT')  # Optional: CDN endpoint
        
        # Media URL for DO Spaces
        if AWS_S3_CUSTOM_DOMAIN:
            MEDIA_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/media/'
        else:
            MEDIA_URL = f'https://{AWS_STORAGE_BUCKET_NAME}.{DO_SPACES_REGION}.digitaloceanspaces.com/media/'
    else:
        # AWS S3
        AWS_S3_REGION_NAME = os.getenv('AWS_S3_REGION_NAME', 'us-east-1')
        AWS_S3_CUSTOM_DOMAIN = os.getenv('AWS_S3_CUSTOM_DOMAIN')  # Optional: CloudFront
        
        # Media URL for AWS S3
        if AWS_S3_CUSTOM_DOMAIN:
            MEDIA_URL = f'https://{AWS_S3_CUSTOM_DOMAIN}/media/'
        else:
            MEDIA_URL = f'https://{AWS_STORAGE_BUCKET_NAME}.s3.{AWS_S3_REGION_NAME}.amazonaws.com/media/'
    
    # Security settings (same for both DO Spaces and S3)
    AWS_DEFAULT_ACL = 'private'  # Private files by default
    AWS_S3_OBJECT_PARAMETERS = {
        'CacheControl': 'max-age=86400',  # 1 day cache
        'ServerSideEncryption': 'AES256',  # Enable encryption
    }
    AWS_S3_FILE_OVERWRITE = False  # Prevent accidental overwrites
    AWS_QUERYSTRING_AUTH = True  # Use signed URLs for private files
    
    # Storage backends
    DEFAULT_FILE_STORAGE = 'core.storage_backends.MediaStorage'
    STATICFILES_STORAGE = 'core.storage_backends.StaticStorage'
    
    MEDIA_ROOT = ''  # Not used with cloud storage
else:
    # Local filesystem storage (development)
    MEDIA_URL = "/media/"
    MEDIA_ROOT = os.path.join(BASE_DIR, "media")


# DRF Settings with JWT Authentication
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
        # "rest_framework.authentication.SessionAuthentication",
        # "rest_framework.authentication.BasicAuthentication",
        # "notifications_system.authentication.SSEAuthentication",
        # "notifications_system.authentication.PassthroughAuthentication",
        # "notifications_system.authentication.WebhookAuthentication",
        # "notifications_system.authentication.InAppAuthentication",
        # "notifications_system.authentication.TokenQueryParamAuthentication",
    ),
    "DEFAULT_PERMISSION_CLASSES": (
        "rest_framework.permissions.IsAuthenticated",
    ),
    'DEFAULT_THROTTLE_CLASSES': [
        'core.throttling.rate_limiter.BurstRateThrottle',
        'core.throttling.rate_limiter.SustainedRateThrottle',
        'core.throttling.rate_limiter.WriteOperationThrottle',
        'core.throttling.rate_limiter.IPRateThrottle',
        # Keep DRF defaults as fallback
        'rest_framework.throttling.UserRateThrottle',
        'rest_framework.throttling.AnonRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        # Core rate limits
        'user': '5000/hour',  # Authenticated users - general limit (~83/min)
        'anon': '500/hour',  # Unauthenticated users (~8/min)
        
        # Burst limits (short-term)
        'burst': '100/minute',  # Burst limit for rapid requests
        'sustained': '10000/day',  # Sustained limit over 24 hours
        
        # Operation-based limits
        'write': '200/hour',  # Write operations (POST, PUT, PATCH, DELETE)
        'read': '10000/hour',  # Read operations (GET, HEAD, OPTIONS)
        
        # IP-based limits
        'ip': '1000/hour',  # Per IP address limit
        
        # Admin limits (higher for admins)
        'admin': '20000/hour',  # Admin users get higher limits
        
        # Public endpoint limits
        'public': '200/hour',  # Public endpoints (no auth)
        
        # Endpoint-specific limits
        'endpoint': '1000/hour',  # Per-endpoint limit
        
        # Authentication-specific limits
        'login': '10/minute',  # Login attempts
        'login_sustained': '200/day',  # Sustained login attempts
        'password_reset': '10/hour',  # Password reset requests
        'magic_link': '5/minute',  # Magic link requests
        'mfa_challenge': '20/hour',  # MFA challenges
        
        # Notification limits
        'notifications_write_burst': '100/min',  # Notification writes per minute
        'notifications_write_sustained': '1000/day',  # Notification writes per day
        
        # Communication limits (from communications/throttles.py)
        'communication_message': '60/minute',
        'communication_thread': '60/minute',
        'communication_notification': '30/minute',
        'order_message': '60/minute',
        'order_message_read_receipt': '10/minute',
        'order_message_search': '10/minute',
        
        # Audit limits
        'audit_log': '10/minute',
        'superadmin_audit': '100/minute',
    },
    'EXCEPTION_HANDLER': 'authentication.exceptions.custom_exception_handler',
    'DEFAULT_VERSIONING_CLASS': 'rest_framework.versioning.URLPathVersioning',
    'DEFAULT_VERSION': '1.0',
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend'
    ],
    # SPECTACULAR_SETTINGS is defined globally above


}




# JWT Token Settings
SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(days=1),  # Admin session valid for 6 hours
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),  # Refresh token valid for 7 days
    "ROTATE_REFRESH_TOKENS": True,  # Generates new refresh token on every refresh
    "BLACKLIST_AFTER_ROTATION": True,  # Prevents reuse of old refresh tokens
    "AUTH_HEADER_TYPES": ("Bearer",),  # Allows "Bearer <token>" in headers
    "USER_ID_FIELD": "id",
    "USER_ID_CLAIM": "user_id",
}

# Security settings for development
SECURE_SSL_REDIRECT = False  # Disabled for development - do not redirect to HTTPS
SECURE_PROXY_SSL_HEADER = None  # Disabled for development
SESSION_COOKIE_SECURE = False  # Allow cookies over HTTP in development
CSRF_COOKIE_SECURE = False  # Allow CSRF cookies over HTTP in development


AUTHENTICATION_BACKENDS = [
    "admin_management.auth.BlacklistAuthenticationBackend",  # Custom authentication
    "django.contrib.auth.backends.ModelBackend",  # Default Django authentication
]

CELERY_BEAT_SCHEDULE = {
    # Real tasks below. Removed placeholder 'your_app.tasks.*' entries to avoid unregistered task errors.
    'expire-referral-bonus-every-night': {
        'task': 'client_wallet.tasks.expire_referral_bonus',
        'schedule': timedelta(days=1),  # Run once every day
    },
    'adjust-wallet-balance-for-referrals': {
        'task': 'client_wallet.tasks.adjust_wallet_balance_for_referrals',
        'schedule': timedelta(days=1),  # Run once every day
    },
    'check-and-update-loyalty-points': {
        'task': 'client_wallet.tasks.check_and_update_loyalty_points',
        'schedule': timedelta(days=7),  # Run once every week
    },
    'daily_soft_delete_cleanup': {
        "task": "users.tasks.deletion.cleanup_soft_deleted_models",
        "schedule": crontab(hour=3, minute=0),  # every day at 3AM
    },
    "move-complete-to-approved-everyday": {
        "task": "orders.tasks.move_complete_orders_to_approved",
        "schedule": crontab(hour=0, minute=0),  # every midnight daily
    },
    "archive-approved-orders-everyday": {
        "task": "orders.tasks.archive_approved_orders",
        "schedule": crontab(hour=1, minute=0),  # every 1 am daily
    },
    'send-daily-digests': {
        'task': 'notifications_system.tasks.send_daily_digests',
        'schedule': crontab(hour=8, minute=0),
    },
        'backfill-group-notification-profiles-every-night': {
        'task': 'notifications_system.tasks.backfill_profiles.backfill_group_notification_profiles',
        'schedule': crontab(hour=3, minute=0),  # Run at 3 AM daily
    },
    'aggregate-content-metrics': {
        'task': 'blog_pages_management.tasks.aggregate_content_metrics',
        'schedule': timedelta(hours=6),  # Run every 6 hours
    },
}
RATELIMIT_VIEW = os.getenv("RATELIMIT_VIEW", "default")
MAX_FAILED_ATTEMPTS = int(os.getenv("MAX_FAILED_ATTEMPTS", "5"))
LOCKOUT_DURATION_MINUTES = int(os.getenv("LOCKOUT_DURATION_MINUTES", "30"))
SESSION_EXPIRATION_DAYS = int(os.getenv("SESSION_EXPIRATION_DAYS", "7"))

LOCKOUT_DURATION = timedelta(minutes=LOCKOUT_DURATION_MINUTES)


# # Sentry settings
# sentry_sdk.init(
#     dsn="YOUR_SENTRY_DSN",  # Replace with your actual DSN
#     integrations=[DjangoIntegration()],
#     traces_sample_rate=1.0,  # Adjust sampling rate if needed
#     send_default_pii=True  # Sends user data (useful for debugging authentication issues)
# )


# SENTRY_DSN = os.getenv("SENTRY_DSN")  # or use settings if you're using django-environ

# if SENTRY_DSN:
#     sentry_sdk.init(
#         dsn=SENTRY_DSN,
#         integrations=[DjangoIntegration()],
#         traces_sample_rate=1.0,
#         send_default_pii=True,
#     )

# FERNET_KEY = Fernet.generate_key().decode() 

TEMPLATES[0]["DIRS"] += [BASE_DIR / "common" / "templates"]


# Token Encryption Key (required for Fernet)
TOKEN_ENCRYPTION_KEY = os.getenv("TOKEN_ENCRYPTION_KEY")

if not TOKEN_ENCRYPTION_KEY:
    if DEBUG:
        # Generate a default key for development/testing
        # WARNING: This should NEVER be used in production
        TOKEN_ENCRYPTION_KEY = Fernet.generate_key().decode()
        import warnings
        warnings.warn(
            "TOKEN_ENCRYPTION_KEY not set. Using auto-generated key for development. "
            "This should be set explicitly in production!",
            RuntimeWarning
        )
    else:
        raise RuntimeError("TOKEN_ENCRYPTION_KEY is not set in the environment.")



# STRIPE_WEBHOOK_SECRET = "whsec_..."

# STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET")



# Notifications System Configurations for override
# --- Delivery behavior ---
NOTIFICATION_CHANNEL_FALLBACKS = {
    "sms": ["email", "push"],
    "push": ["email"],
}
USE_SYNC_RETRIES = False  # Celery in prod

NOTIFICATION_CHANNEL_BACKOFFS = {
    "email": 10,
    "sms": 30,
    "push": 5,
    "in_app": 0,
    "telegram": 5,
    "whatsapp": 5,
    "sse": 1,
}
NOTIFICATION_MAX_RETRIES_PER_CHANNEL = {
    "email": 3,
    "sms": 2,
    "push": 2,
}

# --- What to load ---
LOAD_CENTRAL_NOTIFICATION_CONFIG = False      # no central "notification_event_config.json"
LOAD_BROADCAST_CONFIG = True                  # keep these centralized
LOAD_DIGEST_CONFIG = True

# If you truly don’t have digest/broadcast files, set these to None.
# Otherwise point them at real files. Pick ONE set; don’t redefine later.
NOTIFY_DIGEST_CONFIG_FILE = (
    BASE_DIR / "notifications_system" / "registry" / "configs" / "digest_event_config.json"
)
NOTIFY_BROADCAST_CONFIG_FILE = (
    BASE_DIR / "notifications_system" / "registry" / "configs" / "broadcast_event_config.json"
)

# --- Response Compression Settings ---
# Minimum response size (in bytes) to compress
COMPRESS_MIN_LENGTH = 200  # Compress responses larger than 200 bytes

# Compression level (1-9, where 6 is a good balance between speed and size)
# Higher values = better compression but slower
COMPRESS_LEVEL = 6

# MIME types to compress
COMPRESS_MIMETYPES = [
    'text/html',
    'text/css',
    'text/xml',
    'text/javascript',
    'application/javascript',
    'application/json',
    'application/xml',
    'application/xml+rss',
    'application/rss+xml',
    'application/atom+xml',
    'application/vnd.api+json',  # JSON API format
    'text/plain',
    'text/csv',
    'application/vnd.ms-excel',
]

# Content types to exclude from compression (already compressed or binary)
COMPRESS_EXCLUDE_TYPES = [
    'image/',
    'video/',
    'audio/',
    'application/pdf',
    'application/zip',
    'application/gzip',
    'application/x-gzip',
    'application/x-tar',
    'application/octet-stream',
    'font/',
]

# --- Role wiring ---
NOTIFICATION_AUTOREGISTER_COMMON_ROLES = True
NOTIFICATION_COMMON_ROLE_OVERRIDES = {
    "client": {"*": {"in_app", "email"}},
    "writer": {"*": {"in_app", "email"}},
    "support": {"*": {"in_app"}},
    "admin": {"*": {"in_app", "email"}},
    "super_admin": {"*": {"in_app", "email"}},
    "editor": {"*": {"in_app", "email"}},
}

# --- Throttles / dedupe ---
NOTIFY_INACTIVITY_FALLBACK_HOURS = 3
NOTIFY_EMAIL_COOLDOWN_MINUTES = 30
NOTIFY_DAILY_EMAIL_LIMIT = 5
NOTIFY_WEEKLY_EMAIL_LIMIT = 20
NOTIFY_DISABLE_EMAIL_FALLBACK = False
NOTIFICATION_DEDUPE_WINDOW_SECONDS = 45

# --- Per-app discovery (use ** to match deep trees) ---
NOTIFICATION_EVENT_GLOBS = [
    "**/notification_configs/events.json",
    "**/notifications_config/events.json",  # tolerate singular dir name
]
NOTIFY_APP_EVENTS_SUBDIR = "notification_configs"  # or "notifications_config" if that’s what you use

# Optional: central schemas dir (still useful for $ref resolution)
NOTIFY_EVENTS_DIR = BASE_DIR / "notifications_system" / "registry" / "configs"

# Silences template-related warnings in Django system checks
# Set to False to re-enable warnings for missing templates
NOTIFICATIONS_SILENCE_TEMPLATE_WARNINGS = True

# --- Webhook ---
WEBHOOK_DEFAULT_TIMEOUT = 5
WEBHOOK_HMAC_HEADER = "X-Notif-Signature"
WEBHOOK_HMAC_ALGO = "sha256"
# WEBHOOK_SECRET = ...
